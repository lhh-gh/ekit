package slice

// calCapacity 计算切片缩容后的目标容量（内存优化核心算法）
// 参数说明：
//   - c: 当前切片容量(capacity)
//   - l: 当前切片长度(length)
//
// 返回值说明：
//   - int: 计算后的新容量
//   - bool: 是否执行缩容操作
//
// 缩容策略说明：
//  1. 小容量（<=64）保持不动：避免频繁内存分配影响性能
//  2. 超大容量（>2048）且利用率不足50%：降低到62.5%（避免大规模内存浪费）
//  3. 常规容量（64-2048）且利用率不足25%：压缩到50%（平衡内存和性能）
//  4. 其他情况保持原容量
func calCapacity(c, l int) (int, bool) {
	if c <= 64 {
		return c, false // 小容量不缩容
	}
	if c > 2048 && (c/l >= 2) {
		factor := 0.625
		return int(float32(c) * float32(factor)), true // 渐进式缩容
	}
	if c <= 2048 && (c/l >= 4) {
		return c / 2, true // 激进式缩容
	}
	return c, false
}

// Shrink 切片缩容函数
// 参数说明：
//   - src: 待缩容的原始切片
//
// 返回值说明：
//   - []T: 缩容后的新切片（可能指向新内存空间）
//
// 功能特性：
//   - 智能容量调整：根据不同场景采用差异化的缩容策略
//   - 内存优化：有效回收未使用内存空间
//   - 安全处理：当不需要缩容时直接返回原切片
//   - 数据完整性：保留原有元素顺序
func Shrink[T any](src []T) []T {
	c, l := cap(src), len(src)
	n, changed := calCapacity(c, l)
	if !changed {
		return src // 无需缩容时快速返回
	}

	// 创建新切片并复制数据（触发一次性内存分配）
	s := make([]T, 0, n)
	s = append(s, src...)
	return s
}

//设计要点说明：
//
//容量分级策略：
//≤64：保持容量（Go官方扩容策略的分水岭）
//65~2048：严格缩容条件（4倍冗余）
//2048：较宽松条件（2倍冗余+62.5%因子）
//
//性能平衡考虑：
//避免「抖动缩容」：64以下的切片不缩容，减少内存操作频率
//平滑缩容梯度：大切片采用分数缩容，避免容量陡降
//**内存安全
